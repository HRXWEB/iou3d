# Sutherland-Hodgman算法与顶点顺序的关系

## 1. 算法基本原理

Sutherland-Hodgman算法通过**有向边**来定义多边形的内外关系：

```
对于有向边 P1 → P2：
- 内侧：边的左侧（使用右手定则）
- 外侧：边的右侧
```

## 2. 内外判断公式

```cpp
float side = (x2 - x1) * (point_z - z1) - (z2 - z1) * (point_x - x1);
```

这是向量叉积：`(P2 - P1) × (Point - P1)`

- `side > 0`：点在有向边左侧（内侧）
- `side < 0`：点在有向边右侧（外侧）
- `side = 0`：点在边上

## 3. 顶点顺序的影响

### 逆时针顶点（正确）：
```
  P1(左前) ←── P0(右前)
      ↓           ↑
  P2(左后) ───→ P3(右后)
```

每条边的方向：
- P0→P1: 向左，内侧在下方
- P1→P2: 向下，内侧在右方  
- P2→P3: 向右，内侧在上方
- P3→P0: 向上，内侧在左方

内侧区域正好是多边形内部！

### 顺时针顶点（错误）：
```
  P3(左前) ───→ P0(右前)
      ↑           ↓
  P2(左后) ←── P1(右后)
```

每条边的方向：
- P0→P1: 向下，内侧在右方
- P1→P2: 向左，内侧在下方
- P2→P3: 向上，内侧在左方
- P3→P0: 向右，内侧在上方

内侧区域是多边形外部，导致算法失效！

## 4. 实际测试验证

我们的测试证明：
- **逆时针**：自裁剪得到4个顶点（正确）
- **顺时针**：自裁剪得到0个顶点（错误）

## 5. 数学证明

对于逆时针多边形，所有边的叉积之和为正：
```
总叉积 = Σ(xi * yi+1 - xi+1 * yi) > 0
```

这确保了边的方向性与算法的内外判断一致。

## 结论

Sutherland-Hodgman算法**必须**使用逆时针顶点顺序，否则：
1. 内外判断完全错误
2. 裁剪结果为空或错误
3. IoU计算失效

我们的当前实现是正确的！